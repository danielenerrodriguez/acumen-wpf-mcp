@page "/"
@implements IDisposable
@inject IAppState State

<div class="flex h-full bg-surface-medium dark:bg-[#1a1a2a]">
    @* Left panel: Element Tree *@
    <div class="w-80 flex flex-col shrink-0 panel-card border-r-0 border-t-0 border-b-0">
        <ElementTree @ref="_elementTree" SelectedRefKey="@_selectedRef" OnElementSelected="HandleElementSelected" />
    </div>

    @* Right panel *@
    <div class="flex-1 flex flex-col overflow-hidden gap-px bg-surface-dark dark:bg-[#1a1a2a]">
        @* Top: Properties + Actions *@
        <div class="flex gap-px" style="height: 45%;">
            @* Properties *@
            <div class="flex-1 overflow-hidden bg-surface dark:bg-dm-light">
                <PropertiesPanel RefKey="@_selectedRef" Properties="@_selectedProperties" ChangedKeys="@_changedKeys" />
            </div>
            @* Actions *@
            <div class="w-80 overflow-hidden shrink-0 bg-surface dark:bg-dm-light">
                <ActionsPanel SelectedRefKey="@_selectedRef"
                              Watching="@State.IsWatching"
                              OnWatchToggled="ToggleWatch"
                              OnElementSelected="HandleElementSelected" />
            </div>
        </div>

        @* Middle: Macros *@
        <div class="bg-surface dark:bg-dm-light" style="height: 25%;">
            <MacroRunner />
        </div>

        @* Bottom: Log *@
        <div class="flex-1 overflow-hidden bg-surface dark:bg-dm-light">
            <LogPanel OnNavigateToElement="HandleElementSelected" />
        </div>
    </div>
</div>

@code {
    private string? _selectedRef;
    private Dictionary<string, string>? _selectedProperties;
    private HashSet<string> _changedKeys = new();
    private ElementTree? _elementTree;

    protected override void OnInitialized()
    {
        State.OnAttachChanged += HandleAttachChanged;
        State.OnWatchEntry += HandleWatchEntry;
        State.OnWatchStateChanged += HandleWatchStateChanged;
    }

    private async Task HandleElementSelected(string? refKey)
    {
        _selectedRef = refKey;
        _changedKeys.Clear();
        _selectedProperties = refKey != null ? await State.GetPropertiesAsync(refKey) : null;
        StateHasChanged();
    }

    private void ToggleWatch(bool watching)
    {
        if (watching)
            State.StartWatch();
        else
            State.StopWatch();
        StateHasChanged();
    }

    private void HandleWatchEntry(WatchEntry entry)
    {
        InvokeAsync(() =>
        {
            if (entry.Kind == WatchEntryKind.Focus || entry.Kind == WatchEntryKind.Hover)
            {
                // Auto-select the element and show its properties
                _selectedRef = entry.RefKey;
                _selectedProperties = entry.Properties;
                _changedKeys.Clear();
            }
            else if (entry.Kind == WatchEntryKind.PropertyChange && entry.RefKey == _selectedRef)
            {
                // Highlight the changed property
                _selectedProperties = entry.Properties;
                _changedKeys = new HashSet<string> { entry.ChangedProperty! };
                StateHasChanged();

                // Clear highlight after 1.5s
                _ = Task.Delay(1500).ContinueWith(_ =>
                {
                    _changedKeys = new();
                    InvokeAsync(StateHasChanged);
                });
                return;
            }

            StateHasChanged();
        });
    }

    private void HandleAttachChanged()
    {
        InvokeAsync(() =>
        {
            _elementTree?.Refresh();
            StateHasChanged();
        });
    }

    private void HandleWatchStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        State.OnAttachChanged -= HandleAttachChanged;
        State.OnWatchEntry -= HandleWatchEntry;
        State.OnWatchStateChanged -= HandleWatchStateChanged;
    }
}
