@implements IDisposable
@inject IAppState State
@inject IJSRuntime JS

<div class="flex flex-col h-full">
    <div class="panel-header flex items-center justify-between px-3 py-2 shrink-0">
        <span class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Log</span>
        <button @onclick="Clear" class="btn-secondary text-xs">
            Clear
        </button>
    </div>
    <div id="log-scroll" class="flex-1 overflow-auto p-2 font-mono text-xs space-y-0.5 bg-surface dark:bg-dm-light">
        @foreach (var entry in _logs)
        {
            <div class="flex gap-2">
                <span class="text-gray-400 dark:text-gray-600 shrink-0">@entry.Time.ToString("HH:mm:ss")</span>
                @if (entry.RefKey != null)
                {
                    <button @onclick="() => NavigateToElement(entry.RefKey)"
                            class="text-deltek dark:text-accent-light hover:underline shrink-0 font-medium" title="Select element @entry.RefKey">
                        [@entry.RefKey]
                    </button>
                }
                <span class="@GetLevelColor(entry.Level)">@entry.Message</span>
            </div>
        }
        @if (_logs.Count == 0)
        {
            <p class="text-gray-400 dark:text-gray-600">Ready.</p>
        }
    </div>
</div>

@code {
    [Parameter] public EventCallback<string?> OnNavigateToElement { get; set; }

    private List<LogEntry> _logs = new();
    private bool _shouldScroll;

    protected override void OnInitialized()
    {
        _logs = new(State.RecentLogs);
        _shouldScroll = _logs.Count > 0;
        State.OnLog += HandleLog;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScroll)
        {
            _shouldScroll = false;
            try { await JS.InvokeVoidAsync("scrollToBottom", "log-scroll"); }
            catch (ObjectDisposedException) { }
        }
    }

    private void HandleLog(LogEntry entry)
    {
        InvokeAsync(() =>
        {
            _logs.Add(entry);
            if (_logs.Count > 500)
                _logs.RemoveRange(0, _logs.Count - 500);
            _shouldScroll = true;
            StateHasChanged();
        });
    }

    private async Task NavigateToElement(string refKey)
    {
        await OnNavigateToElement.InvokeAsync(refKey);
    }

    private void Clear()
    {
        _logs.Clear();
        StateHasChanged();
    }

    private static string GetLevelColor(LogLevel level) => level switch
    {
        LogLevel.Success => "text-emerald-600 dark:text-green-400",
        LogLevel.Warning => "text-amber-600 dark:text-yellow-400",
        LogLevel.Error => "text-red-600 dark:text-red-400",
        _ => "text-gray-600 dark:text-gray-300"
    };

    public void Dispose()
    {
        State.OnLog -= HandleLog;
    }
}
