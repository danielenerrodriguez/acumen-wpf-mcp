@implements IDisposable
@inject IAppState State

<div class="flex flex-col h-full">
    <div class="panel-header flex items-center justify-between px-3 py-2 shrink-0">
        <span class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Macros</span>
        <button @onclick="RefreshMacros" class="btn-secondary text-xs">
            Refresh
        </button>
    </div>
    <div class="flex-1 flex overflow-hidden text-xs">
        @* Macro list *@
        <div class="w-48 border-r border-surface-dark dark:border-dm-border overflow-auto shrink-0 bg-surface-light dark:bg-dm-light">
            @if (_macros == null || _macros.Count == 0)
            {
                <p class="text-gray-400 dark:text-gray-500 p-2">No macros found.</p>
            }
            else
            {
                @foreach (var m in _macros)
                {
                    var isNew = _newMacroNames.Contains(m.Name);
                    var isSelected = m == _selected;
                    <button @onclick="() => SelectMacro(m)"
                            @ondblclick="() => OpenInEditor(m)"
                            title="Double-click to open in editor"
                            class="w-full text-left px-3 py-1.5 transition-all truncate @(isNew ? "text-emerald-700 dark:text-green-400 bg-emerald-50 dark:bg-green-900/20 animate-pulse font-medium" : isSelected ? "bg-deltek-bg dark:bg-accent-bg text-deltek dark:text-accent-light font-medium border-l-2 border-deltek dark:border-accent" : "text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-dm-lighter")">
                        @m.DisplayName
                    </button>
                }
            }
        </div>

        @* Macro detail / run *@
        <div class="flex-1 overflow-auto p-3">
            @if (_selected == null)
            {
                <p class="text-gray-400 dark:text-gray-500">Select a macro to run.</p>
            }
            else
            {
                <div class="space-y-2">
                    <div>
                        <span class="text-deltek dark:text-accent-light font-semibold">@_selected.DisplayName</span>
                        <p class="text-gray-500 dark:text-gray-400 mt-0.5">@_selected.Description</p>
                    </div>

                    @if (_selected.Parameters.Count > 0)
                    {
                        <div class="space-y-1">
                            @foreach (var p in _selected.Parameters)
                            {
                                <div class="flex items-center gap-2">
                                    <label class="text-gray-500 dark:text-gray-400 w-28 shrink-0 truncate font-medium" title="@p.Description">
                                        @p.Name@(p.Required ? "*" : "")
                                    </label>
                                    <input @bind="_paramValues[p.Name]" @bind:event="oninput"
                                           placeholder="@(p.Default ?? p.Description)"
                                           class="input-field flex-1" />
                                </div>
                            }
                        </div>
                    }

                    @if (_running)
                    {
                        <button @onclick="CancelMacro"
                                class="bg-red-600 hover:bg-red-700 text-white px-4 py-1.5 rounded text-xs font-medium transition-colors">
                            Cancel
                        </button>
                    }
                    else
                    {
                        <button @onclick="RunMacro"
                                class="btn-primary px-4 py-1.5">
                            Run Macro
                        </button>
                    }
                </div>
            }
        </div>
    </div>
</div>

@code {
    private List<MacroSummary>? _macros;
    private MacroSummary? _selected;
    private Dictionary<string, string> _paramValues = new();
    private bool _running;
    private HashSet<string> _newMacroNames = new();

    protected override void OnInitialized()
    {
        RefreshMacros();
        State.OnMacrosChanged += HandleMacrosChanged;
    }

    private void HandleMacrosChanged()
    {
        InvokeAsync(() =>
        {
            // Capture existing names before refresh to detect new entries
            var oldNames = new HashSet<string>(_macros?.Select(m => m.Name) ?? Enumerable.Empty<string>());

            try { _macros = State.ListMacros(); } catch { _macros = new(); }

            _newMacroNames = new HashSet<string>(
                (_macros?.Select(m => m.Name) ?? Enumerable.Empty<string>())
                .Where(n => !oldNames.Contains(n)));

            StateHasChanged();

            // Clear new-macro highlight after 3 seconds
            if (_newMacroNames.Count > 0)
            {
                _ = Task.Delay(3000).ContinueWith(_ => InvokeAsync(() =>
                {
                    _newMacroNames.Clear();
                    StateHasChanged();
                }));
            }
        });
    }

    public void Dispose()
    {
        State.OnMacrosChanged -= HandleMacrosChanged;
    }

    private void RefreshMacros()
    {
        try { _macros = State.ListMacros(); } catch { _macros = new(); }
        _newMacroNames.Clear();
        StateHasChanged();
    }

    private void SelectMacro(MacroSummary macro)
    {
        _selected = macro;
        _paramValues = new();
        foreach (var p in macro.Parameters)
        {
            _paramValues[p.Name] = p.Default ?? "";
        }
    }

    private void OpenInEditor(MacroSummary macro)
    {
        State.OpenMacroFile(macro.Name);
    }

    private async Task RunMacro()
    {
        if (_selected == null || _running) return;
        _running = true;
        StateHasChanged();

        try
        {
            // Filter out empty params
            var filtered = _paramValues
                .Where(kv => !string.IsNullOrEmpty(kv.Value))
                .ToDictionary(kv => kv.Key, kv => kv.Value);

            await State.RunMacroAsync(_selected.Name, filtered);
        }
        catch { }
        finally
        {
            _running = false;
            StateHasChanged();
        }
    }

    private void CancelMacro()
    {
        State.CancelMacro();
    }
}
