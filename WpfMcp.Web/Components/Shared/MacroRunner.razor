@implements IDisposable
@inject IAppState State

<div class="flex flex-col h-full">
    <div class="panel-header flex items-center justify-between px-3 py-2 shrink-0">
        <span class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Macros</span>
        <button @onclick="RefreshMacros" class="btn-secondary text-xs">
            Refresh
        </button>
    </div>
    <div class="flex-1 flex overflow-hidden text-xs">
        @* Macro list *@
        <div class="w-48 border-r border-surface-dark dark:border-dm-border overflow-auto shrink-0 bg-surface-light dark:bg-dm-light">
            @if (_macros == null || _macros.Count == 0)
            {
                <p class="text-gray-400 dark:text-gray-500 p-2">No macros found.</p>
            }
            else
            {
                @foreach (var m in _macros)
                {
                    var isNew = _newMacroNames.Contains(m.Name);
                    var isSelected = m == _selected;
                    <button @onclick="() => SelectMacro(m)"
                            @ondblclick="() => OpenInEditor(m)"
                            title="Double-click to open in editor"
                            class="w-full text-left px-3 py-1.5 transition-all truncate @(isNew ? "text-emerald-700 dark:text-green-400 bg-emerald-50 dark:bg-green-900/20 animate-pulse font-medium" : isSelected ? "bg-deltek-bg dark:bg-accent-bg text-deltek dark:text-accent-light font-medium border-l-2 border-deltek dark:border-accent" : "text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-dm-lighter")">
                        @m.DisplayName
                    </button>
                }
            }
        </div>

        @* Macro detail / run *@
        <div class="flex-1 overflow-auto p-3">
            @if (_selected == null)
            {
                <p class="text-gray-400 dark:text-gray-500">Select a macro to run.</p>
            }
            else
            {
                <div class="space-y-2">
                    <div>
                        <span class="text-deltek dark:text-accent-light font-semibold">@_selected.DisplayName</span>
                        <p class="text-gray-500 dark:text-gray-400 mt-0.5">@_selected.Description</p>
                    </div>

                    @if (_selected.Parameters.Count > 0)
                    {
                        <div class="space-y-1">
                            @foreach (var p in _selected.Parameters)
                            {
                                var browseKind = GetBrowseKind(p.Name);
                                <div class="flex items-center gap-2">
                                    <label class="text-gray-500 dark:text-gray-400 w-28 shrink-0 truncate font-medium" title="@p.Description">
                                        @p.Name@(p.Required ? "*" : "")
                                    </label>
                                    <input @bind="_paramValues[p.Name]" @bind:event="oninput"
                                           placeholder="@(p.Default ?? p.Description)"
                                           class="input-field flex-1" />
                                    @if (browseKind != BrowseKind.None)
                                    {
                                        <button @onclick="() => BrowseForPath(p.Name, browseKind)"
                                                disabled="@_browsing"
                                                title="@(browseKind == BrowseKind.Folder ? "Browse for folder..." : "Browse for file...")"
                                                class="btn-secondary px-1.5 py-1 shrink-0 @(_browsing ? "opacity-50 cursor-not-allowed" : "")">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                                                <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                                            </svg>
                                        </button>
                                    }
                                </div>
                            }
                        </div>
                    }

                    @if (_running)
                    {
                        <button @onclick="CancelMacro"
                                class="bg-red-600 hover:bg-red-700 text-white px-4 py-1.5 rounded text-xs font-medium transition-colors">
                            Cancel
                        </button>
                    }
                    else
                    {
                        <button @onclick="RunMacro"
                                class="btn-primary px-4 py-1.5">
                            Run Macro
                        </button>
                    }
                </div>
            }
        </div>
    </div>
</div>

@code {
    private List<MacroSummary>? _macros;
    private MacroSummary? _selected;
    private Dictionary<string, string> _paramValues = new();
    private bool _running;
    private bool _browsing;
    private HashSet<string> _newMacroNames = new();

    private enum BrowseKind { None, File, Folder }

    protected override void OnInitialized()
    {
        RefreshMacros();
        State.OnMacrosChanged += HandleMacrosChanged;
    }

    private void HandleMacrosChanged()
    {
        InvokeAsync(() =>
        {
            // Capture existing names before refresh to detect new entries
            var oldNames = new HashSet<string>(_macros?.Select(m => m.Name) ?? Enumerable.Empty<string>());

            try { _macros = State.ListMacros(); } catch { _macros = new(); }

            _newMacroNames = new HashSet<string>(
                (_macros?.Select(m => m.Name) ?? Enumerable.Empty<string>())
                .Where(n => !oldNames.Contains(n)));

            // Re-select the current macro to pick up updated defaults (e.g., after auto-save)
            if (_selected != null)
            {
                var refreshed = _macros?.FirstOrDefault(m => m.Name == _selected.Name);
                if (refreshed != null)
                {
                    // Preserve user-entered values, but update the selected macro reference
                    var oldValues = new Dictionary<string, string>(_paramValues);
                    _selected = refreshed;
                    _paramValues = new();
                    foreach (var p in refreshed.Parameters)
                    {
                        // Keep user's current value if they've typed something; otherwise use new default
                        _paramValues[p.Name] = oldValues.TryGetValue(p.Name, out var v) ? v : (p.Default ?? "");
                    }
                }
            }

            StateHasChanged();

            // Clear new-macro highlight after 3 seconds
            if (_newMacroNames.Count > 0)
            {
                _ = Task.Delay(3000).ContinueWith(_ => InvokeAsync(() =>
                {
                    _newMacroNames.Clear();
                    StateHasChanged();
                }));
            }
        });
    }

    public void Dispose()
    {
        State.OnMacrosChanged -= HandleMacrosChanged;
    }

    private void RefreshMacros()
    {
        try { _macros = State.ListMacros(); } catch { _macros = new(); }
        _newMacroNames.Clear();
        StateHasChanged();
    }

    private void SelectMacro(MacroSummary macro)
    {
        _selected = macro;
        _paramValues = new();
        foreach (var p in macro.Parameters)
        {
            _paramValues[p.Name] = p.Default ?? "";
        }
    }

    private void OpenInEditor(MacroSummary macro)
    {
        State.OpenMacroFile(macro.Name);
    }

    private async Task RunMacro()
    {
        if (_selected == null || _running) return;
        _running = true;
        StateHasChanged();

        try
        {
            // Filter out empty params
            var filtered = _paramValues
                .Where(kv => !string.IsNullOrEmpty(kv.Value))
                .ToDictionary(kv => kv.Key, kv => kv.Value);

            await State.RunMacroAsync(_selected.Name, filtered);
        }
        catch { }
        finally
        {
            _running = false;
            StateHasChanged();
        }
    }

    private void CancelMacro()
    {
        State.CancelMacro();
    }

    /// <summary>
    /// Detect whether a parameter name suggests a file or folder path.
    /// </summary>
    private static BrowseKind GetBrowseKind(string paramName)
    {
        var lower = paramName.ToLowerInvariant();
        if (lower.Contains("dir") || lower.Contains("folder"))
            return BrowseKind.Folder;
        if (lower.Contains("path") || lower.Contains("file"))
            return BrowseKind.File;
        return BrowseKind.None;
    }

    /// <summary>
    /// Open a file/folder browse dialog and populate the parameter input with the selected path.
    /// </summary>
    private async Task BrowseForPath(string paramName, BrowseKind kind)
    {
        if (_browsing) return;
        _browsing = true;
        StateHasChanged();

        try
        {
            var currentValue = _paramValues.TryGetValue(paramName, out var v) ? v : null;

            var selected = kind == BrowseKind.Folder
                ? await State.BrowseForFolderAsync(currentValue)
                : await State.BrowseForFileAsync(currentValue);

            if (!string.IsNullOrEmpty(selected))
            {
                _paramValues[paramName] = selected;
            }
        }
        catch { }
        finally
        {
            _browsing = false;
            StateHasChanged();
        }
    }
}
