# WPF MCP Server

Generic MCP (Model Context Protocol) server that automates any WPF application via UI Automation. Primary target is **Deltek Acumen Fuse** (`Fuse.exe`), which uses Infragistics controls.

## Project Structure

```
WpfMcp.slnx              # Solution (3 projects)
WpfMcp/                   # Main project (net9.0-windows, UseWPF)
WpfMcp.Web/               # Razor Class Library — Blazor Server dashboard components
WpfMcp.Tests/             # xUnit tests
publish/macros/           # Version-controlled macro YAML files (product subfolders)
publish/Shortcuts/        # Exported .lnk shortcuts (gitignored, generated by --export-all)
publish/export-shortcuts.cmd  # Generates .lnk shortcuts for all macros
publish/launch-cli.cmd       # Opens interactive CLI mode
publish/run-indefinite.cmd   # Starts server with --no-idle (runs forever)
.github/workflows/        # CI/CD: build, test, release zip with auto-changelog
```

Flat layout — NO `src/` or `tests/` subdirectories.

## Architecture: Two-Process Proxy

```
OpenCode (WSL)
  → cmd.exe /c WpfMcp.exe --mcp-connect  (non-elevated, MCP stdio server)
    → auto-launches WpfMcp.exe --server   (elevated via BeyondTrust/UAC)
    → UiaProxyClient connects to WpfMcp_UIA named pipe
    → MCP tool calls proxy through pipe → UiaProxyServer executes UIA commands
```

**Why elevation?** Fuse's UIA providers only respond to elevated processes. Non-elevated processes see only `FrameworkId="Win32"` with a single TitleBar child.

### Web Dashboard

The elevated `--server` process also hosts a **Blazor Server dashboard** on `http://localhost:5112` for interactive WPF element inspection, actions, and macro running.

```
WpfMcp.Web (RCL)           → IAppState interface + DTOs + Razor components
WpfMcp (main project)      → AppState implementation + WebServer.cs Kestrel host
```

- **Styling**: Tailwind CSS via CDN, dual light/dark theme with Deltek-inspired branding
- **Communication**: Blazor Server's built-in SignalR (real-time, no polling)
- **Binding**: `http://*:5112` (all interfaces, accessible from WSL and LAN)
- **One-way dependency**: `WpfMcp` references `WpfMcp.Web`; the RCL has no reference back
- **Shared singletons**: `UiaEngine.Instance`, `ElementCache`, `MacroEngine`, and `_commandLock` are shared between pipe server and web dashboard via `AppState`

## Build & Test

```bash
# MUST kill running instances first or build fails with file lock errors
cmd.exe /c "taskkill /IM WpfMcp.exe /F 2>nul"

# Build
cmd.exe /c "cd /d C:\WpfMcp && dotnet build WpfMcp.slnx"

# Test (189 tests)
cmd.exe /c "cd /d C:\WpfMcp && dotnet test WpfMcp.Tests"

# Release build + local publish
cmd.exe /c "cd /d C:\WpfMcp && dotnet build WpfMcp\WpfMcp.csproj -c Release"
```

The machine has .NET 10 preview SDK installed; we target `net9.0-windows`.

## Critical Technical Constraints

### WSL ↔ Windows
- OpenCode runs on WSL, launches Windows exe via `cmd.exe /c`
- WSL `/mnt/c/` writes can silently fail — use `cmd.exe` or `powershell.exe` for writing Windows files when reliability matters
- Use the `Write` tool for simple file writes; it works for most cases

### Named Pipe ACL
- Elevated server pipe needs `PipeSecurity` with `AuthenticatedUserSid` or non-elevated clients can't connect

### MCP Logging
- Must use `builder.Logging.ClearProviders()` then add console with `LogToStandardErrorThreshold = LogLevel.Trace` to prevent stdout corruption (MCP uses stdout for JSON-RPC)

### NuGet
- Local `nuget.config` with `<clear />` needed to avoid Infragistics NuGet source errors
- `ModelContextProtocol` NuGet version: `0.9.0-preview.2`
- Server instructions (`options.ServerInstructions`) inject macro list + full knowledge base YAML at MCP handshake

### Publish / Runtime
- `publish/` folder must include `runtimes/` subdirectory — `System.Text.Encodings.Web` v10.0.0.0 assembly is needed at runtime
- `Environment.ProcessPath` for exe location (NOT `AppContext.BaseDirectory` which points to temp extraction dir for single-file publish)

### Process Launch Relay
- Some apps (Windows 11 Notepad, store apps) exit immediately on `Process.Start` and relaunch under a different PID
- `WaitForProcessByNameAsync` handles this by falling back to process-name search when the tracked PID exits

## Key Code Patterns

### JsonElement Null Safety
When MCP passes `null` for optional params, always check `ValueKind` before calling `GetString()`/`GetInt32()`:
```csharp
private static string? GetStringArg(JsonElement args, string name) =>
    args.TryGetProperty(name, out var v) && v.ValueKind == JsonValueKind.String ? v.GetString() : null;
```

### YamlDotNet Configuration
Always use `UnderscoredNamingConvention` and `IgnoreUnmatchedProperties`. Use `[YamlMember(Alias = "...")]` attributes on POCOs. Shared deserializer/serializer instances live in `YamlHelpers.cs` — never create inline instances.

### ControlType Lookup
Uses reflection-based static dictionary on `ControlType`'s public fields.

### Key Parsing
`ParseVirtualKey` uses `System.Windows.Input.Key` enum + `KeyInterop.VirtualKeyFromKey()`. Bare digits "0"-"9" must be aliased to "D0"-"D9".

### xUnit Test Isolation
- Pipe tests must use unique pipe names per test (GUID suffix) since xUnit runs in parallel
- `WpfToolsTests` and `ProxyResponseFormattingTests` share the static `WpfTools.Proxy` — both use `[Collection("WpfTools")]` to prevent parallel execution
- MacroEngine tests use `enableWatcher: false` constructor param to avoid filesystem race conditions
- FileSystemWatcher tests need ~1500ms delay for debounce (500ms) + processing

## Macro System

### YAML Format
```yaml
name: My Macro
description: What it does
timeout: 60
parameters:
  - name: paramName
    description: What this param is
    required: true
    default: "optional default"
steps:
  - action: launch
    exe_path: "{{paramName}}"
    if_not_running: true
    timeout: 45
  - action: wait_for_window
    title_contains: "My App"
    timeout: 30
  - action: focus
  - action: find
    automation_id: myElement
    save_as: el
  - action: click
    ref: el
  - action: type
    text: "{{paramName}}"
  - action: send_keys
    keys: "Ctrl+S"
  - action: wait
    seconds: 2
  - action: verify
    ref: el
    property: value          # value, name, toggle_state, is_enabled, expand_state, is_selected, control_type, automation_id
    expected: "Done"
    match_mode: equals       # equals (default), contains, not_equals, regex, starts_with
    message: "Optional custom failure message"
  - action: run_script
    command: "powershell.exe"
    arguments: "-NoProfile -Command \"echo hello\""
    save_output_as: scriptOutput   # stores trimmed stdout as {{scriptOutput}} for subsequent steps
    ignore_exit_code: true         # non-zero exit code won't fail the step (default: false)
```

### Step Types
`launch`, `wait_for_window`, `wait_for_enabled`, `attach`, `focus`, `find`, `find_by_path`, `click`, `right_click`, `type`, `set_value`, `get_value`, `send_keys`, `keys` (alias), `wait`, `snapshot`, `screenshot`, `properties`, `children`, `file_dialog`, `verify`, `include`, `macro`, `run_script`

### Macro Reusability: `include` vs `macro`

**`action: include`** — Load-time step inlining (recommended for MCP):
```yaml
steps:
  - action: include
    macro_name: acumen-fuse/import-xer
    params:
      filePath: "{{inputFile}}"   # Maps child's filePath param to parent's inputFile param
```
- Referenced macro's steps are **inlined at load time** during `MacroEngine.Reload()` — the result is a flat list of steps with zero runtime overhead
- `ExecuteDefinitionAsync()` also expands includes at runtime for macros that bypass `Reload()` (drag-and-drop, CLI run-file, `executeMacroYaml`)
- The `params` field remaps parameter names: `{{childParam}}` in included steps becomes `{{parentParam}}` (or a literal value)
- Supports nested includes (A includes B which includes C)
- Detects circular includes and reports load errors
- **Safe for MCP tool calls** — no nested execution, no extra timeouts
- Works in all execution paths: MCP tools, web dashboard, CLI, drag-and-drop shortcuts

**`action: macro`** — Runtime nested execution (for web dashboard/CLI/drag-and-drop only):
```yaml
steps:
  - action: macro
    macro_name: acumen-fuse/import-xer
    params:
      filePath: "C:\\data\\test.xer"
```
- Executes the referenced macro at runtime as a nested call
- Uses the nested macro's own `timeout` field (not the default 5s step timeout)
- Propagates `onLog` callback with parent step prefix (e.g., `[Macro] Step 3 > Step 2/5: ...`)
- **Do NOT use in macros invoked via MCP tools** — the parent + nested execution time will exceed the ~15-20s MCP client timeout. Use `include` instead for MCP-safe macros.

### Macros Path Resolution
`Constants.ResolveMacrosPath()`: explicit `--macros-path` arg > `WPFMCP_MACROS_PATH` env var > `macros/` next to exe

### File Watcher
`MacroEngine` watches the macros folder with FileSystemWatcher (500ms debounce). Auto-reloads on create/modify/delete/rename. `LoadErrors` property tracks YAML parse failures.

### Macro Change Protocol
When macros are created, modified, deleted, or renamed, always update the product knowledge base (`publish/macros/{product}/_knowledge.yaml`) to reflect the changes:
- Update `workflows` section: add/remove/update `existing_macro` references, step descriptions, and `last_tested` dates
- Update `saving_workflows.best_practices` if new patterns or conventions are established
- Update the `Last updated` header comment with today's date and a brief description
- Remove stale references to deleted macros
- Add new workflow entries for newly created macros
- Validate the YAML parses without errors after editing

## Conventions (DLTKEngineering)

- Repo naming: `[team]-[repo]`, lowercase+hyphens
- Branch prefixes: `feature/`, `bugfix/`, `release/`
- xUnit for tests
- File-scoped namespaces (`namespace WpfMcp;`)
- Private fields: `_camelCase`
- Constants: `PascalCase`

## Git

- Remote: `https://github.com/danielenerrodriguez/acumen-wpf-mcp`
- Branch: `master`
- Do NOT push — let the user push manually
- Do NOT create ZenDesk tickets

## Knowledge Base System

Product-specific knowledge bases provide AI agents with the context they need to navigate WPF applications — automation IDs, keytips, keyboard shortcuts, ribbon structure, workflows, and more.

### File Convention
- Knowledge bases are YAML files named `_knowledge.yaml` (underscore prefix)
- Located in product subfolders: `publish/macros/{product}/_knowledge.yaml`
- Skipped by the macro loader (underscore prefix exclusion)
- Must have `kind: knowledge-base` as a top-level field

### How It Works
1. **`MacroEngine.Reload()`** loads `_knowledge.yaml` files into `_knowledgeBases` dictionary (keyed by product folder name)
2. **`wpf_macro_list`** includes a condensed summary for each knowledge base (verified keytips, key automation IDs, workflow/tip counts)
3. **MCP Resource** `knowledge://{productName}` serves the full YAML content via `Resources.cs`
4. Parsed as `Dictionary<string, object>` (not POCOs) — flexible, no C# changes needed when YAML schema changes

### Knowledge Base YAML Structure
```yaml
kind: knowledge-base
update_instructions: { ... }    # When/how AI agents should update this file
installation: { ... }           # Exe path, samples, templates, skills directories
application: { ... }            # Name, version, startup phases
keyboard_shortcuts: [ ... ]     # InputBinding shortcuts (Ctrl+N, Ctrl+O, etc.)
keytips: { ... }                # Application menu + ribbon tab keytip sequences
ribbon: { ... }                 # Complete ribbon structure (tabs, groups, tools, commands)
automation_ids: { ... }         # 80+ IDs by category (panels, grids, trees, etc.)
workflows: [ ... ]              # Step-by-step recipes for common tasks
navigation_tips: [ ... ]        # Practical tips for driving the application
data_formats: { ... }           # Supported import/export formats
```

### Current Knowledge Bases
- `acumen-fuse` — Deltek Acumen Fuse (1800+ lines, 100+ automation IDs, 15 workflows, 19 navigation tips)

## File Reference

| File | Purpose |
|------|---------|
| `WpfMcp/Program.cs` | Entry point: mode routing (default=server, `--cli`, `--mcp-connect`, `--mcp`, `--export-all`, `--no-idle`, `--idle-timeout`, `run`, drag-drop) |
| `WpfMcp/Constants.cs` | Shared constants/config, `ResolveMacrosPath()`, `ResolveShortcutsPath()`, `ServerIdleTimeoutMinutes` (mutable), `WebPort`, `Commands` nested class |
| `WpfMcp/Tools.cs` | 20 MCP tool definitions (including watch mode) |
| `WpfMcp/UiaEngine.cs` | Core UI Automation engine (STA thread, SendInput, launch, wait, `ReadElementProperty()`) |
| `WpfMcp/UiaProxy.cs` | Proxy client/server over named pipe + web dashboard startup |
| `WpfMcp/MacroDefinition.cs` | YAML POCOs for macros + `KnowledgeBase` + `SaveMacroResult` + `ExportMacroResult` records |
| `WpfMcp/MacroEngine.cs` | Load/validate/execute/save/export macros, FileSystemWatcher, knowledge base loading |
| `WpfMcp/MacroSerializer.cs` | YAML serialization (`ToYaml`, `SaveToFile`) |
| `WpfMcp/CliMode.cs` | Interactive CLI for manual testing (`read-prop`, `verify` commands) |
| `WpfMcp/ElementCache.cs` | Thread-safe LRU element reference cache (e1, e2, ..., max 500) |
| `WpfMcp/JsonHelpers.cs` | Shared JSON array parsing utilities (`ParseJsonArray`, `ConvertJsonElement`) |
| `WpfMcp/YamlHelpers.cs` | Shared YAML deserializer/serializer singleton instances |
| `WpfMcp/ShortcutCreator.cs` | COM-based `.lnk` shortcut creation via `WScript.Shell` |
| `WpfMcp/Resources.cs` | MCP resources — `knowledge://{productName}` endpoint |
| `WpfMcp/Web/WebServer.cs` | Kestrel startup for Blazor Server dashboard |
| `WpfMcp/Web/AppState.cs` | `IAppState` implementation wrapping UiaEngine + ElementCache + MacroEngine |
| `WpfMcp.Web/IAppState.cs` | Interface + DTOs for web dashboard (ElementInfo, ActionResult, etc.) |
| `WpfMcp.Web/Components/` | Razor components: App, Routes, Layout, Dashboard, ElementTree, TreeNode, PropertiesPanel, ActionsPanel, MacroRunner, LogPanel |

## Macro Saving (`wpf_save_macro`)

AI agents can save workflows they've performed as reusable macro YAML files using the `wpf_save_macro` MCP tool.

### How It Works
1. Agent passes steps as a JSON array, plus name/description/parameters
2. `MacroEngine.ValidateSteps()` checks all action types and required fields
3. `MacroEngine.GetProductFolder()` scans knowledge bases for a matching `process_name` field to auto-derive the product folder (e.g., `Fuse` → `acumen-fuse`)
4. Steps are serialized to clean YAML (no JSON-in-YAML) via YamlDotNet
5. File is written to `{macrosPath}/{productFolder}/{name}.yaml`
6. FileSystemWatcher auto-reloads the new macro immediately

### Key Design Decisions
- Steps passed as JSON string in, written as clean YAML out
- Product folder auto-derived from attached process matching knowledge base `application.process_name`
- Validation against 22 known action types with per-action required field checks
- `force` parameter (bool, default false) for overwrite protection
- `SaveMacroResult` record returns `(Ok, FilePath, MacroName, Message)`

### Error Cases
1. No process attached → error
2. Can't derive product folder → error with suggestion to include folder in name
3. Macro already exists and `force` is false → error with overwrite hint
4. Invalid step action → error listing all valid actions
5. Missing required step fields → error naming the missing field and step number

### Files Modified
- `MacroDefinition.cs` — `SaveMacroResult` record
- `MacroEngine.cs` — `SaveMacro()`, `GetProductFolder()`, `ValidateSteps()`, `MacrosPath` property
- `Tools.cs` — `wpf_save_macro` MCP tool (uses `JsonHelpers.ParseJsonArray`)
- `UiaProxy.cs` — `saveMacro` case in `ExecuteCommand()` (uses `JsonHelpers.ParseJsonArray`)
- `JsonHelpers.cs` — shared `ParseJsonArray()` / `ConvertJsonElement()` utilities
- `UiaEngine.cs` — `ProcessName` property
- `_knowledge.yaml` — `saving_workflows` section under `update_instructions`

## Macro Export (`wpf_export_macro`)

Macros can be exported as Windows shortcut (.lnk) files that users can double-click to run without needing OpenCode/MCP.

### How It Works
1. The shortcut targets `WpfMcp.exe "path\to\macro.yaml"`, reusing the existing drag-and-drop execution mode
2. The drag-and-drop mode handles everything: YAML parsing, parameter prompting, elevated server connection, execution
3. The client process runs **non-elevated** — `EnsureServerAndConnectAsync` only triggers UAC if the elevated server isn't already running (first run only)
4. Shortcuts are placed in `Shortcuts/` as a sibling of the `macros/` folder, mirroring the macro directory structure

### Access Points
- **MCP tool**: `wpf_export_macro` — pass a macro name or `"all"` to export all macros
- **CLI mode**: `export <name>` or `export-all`
- **Command line**: `WpfMcp.exe --export-all [--shortcuts-path C:\path] [--force]`
- **Post-install**: `export-shortcuts.cmd` runs `--export-all` for users who extract the release zip

### Shortcuts Path Resolution
`Constants.ResolveShortcutsPath()`: explicit `--shortcuts-path` arg > `WPFMCP_SHORTCUTS_PATH` env var > `Shortcuts/` as sibling of macros folder

### Key Design Decisions
- Shortcuts do NOT have the "Run as administrator" flag — elevation is handled internally by the drag-and-drop mode
- `.lnk` files are created via COM interop (`WScript.Shell`) with run-as-admin support via binary patch at byte 0x15
- Shortcut names match macro names (e.g., `import-xer.lnk`)
- `ExportMacroResult` record returns `(Ok, ShortcutPath, MacroName, Message)`
- Overwrite protection via `force` parameter (default false)
- Generated `.lnk` files are gitignored (machine-specific absolute paths)

### Files
- `ShortcutCreator.cs` — COM-based `.lnk` creation utility
- `MacroEngine.cs` — `ExportMacro()`, `ExportAllMacros()`
- `Tools.cs` — `wpf_export_macro` MCP tool
- `UiaProxy.cs` — `exportMacro`, `exportAllMacros` proxy commands
- `CliMode.cs` — `export`, `export-all` CLI commands
- `Program.cs` — `--export-all`, `--shortcuts-path` CLI flags
- `publish/export-shortcuts.cmd` — Post-extraction script to generate shortcuts

## Live Updates & Focus Watcher

### Event-Driven Updates
The web dashboard receives live updates via in-process C# events (not pipe push — the named pipe is request/response only):
- **`OnLog` event**: New log entries trigger `StateHasChanged()` in `LogPanel`, with auto-scroll via JS interop (`scrollToBottom`)
- **`OnAttachChanged` event**: Fires when a process is attached/detached — `MainLayout` refreshes status bar, `Dashboard` refreshes element tree
- **`OnWatchEntry` event**: New watch entries trigger element auto-selection and property highlighting in Dashboard
- **`OnWatchStateChanged` event**: Fires when watch is started/stopped from any source — Dashboard updates the Watch toggle button
- **`OnMacrosChanged` event**: Fires when FileSystemWatcher reloads macros — MacroRunner auto-refreshes the macro list
- **Status bar polling**: `MainLayout` polls `GetStatus()` every 3 seconds for process name + PID display

### Watch Mode (Server-Side Sessions)

Watch mode records focus changes, hover changes, keypresses, and property diffs in the attached WPF application. The watch timer runs **server-side in AppState** (not in the Dashboard), so it works from MCP tools, CLI, and web dashboard simultaneously.

**Architecture:**
1. `AppState` owns a 500ms `System.Threading.Timer` that polls `AutomationElement.FocusedElement` and `AutomationElement.FromPoint()` (via `GetCursorPos`)
2. Each detected change creates a structured `WatchEntry` record, appended to the active `WatchSession`
3. Entries also flow into the main log (for dashboard visibility) and fire `OnWatchEntry` event
4. Dashboard subscribes to `OnWatchEntry` for live element selection and property highlighting
5. Only the **last completed session** is retained in memory (no disk persistence)

**Watch session lifecycle:**
- `StartWatch()` → creates new `WatchSession`, starts timer, starts keyboard hook, resets runtime IDs, fires `OnWatchStateChanged`
- `StopWatch()` → stops timer, stops keyboard hook, timestamps session, moves to `_lastSession`, fires `OnWatchStateChanged`
- `GetWatchSession()` → returns current (active) or last (completed) session

**Access points:**
- **MCP tools**: `wpf_watch_start`, `wpf_watch_stop`, `wpf_watch_status`
- **CLI commands**: `watch`, `watch stop`, `watch status`
- **Web dashboard**: Watch toggle button in ActionsPanel (uses same server-side session)

### WatchEntry Types
- **`Focus`** — keyboard focus changed to a new element
- **`Hover`** — mouse cursor moved over a new element
- **`Keypress`** — a key was pressed while the attached application had foreground focus
- **`PropertyChange`** — a property value changed on the currently tracked element

Each entry includes: `Time`, `Kind`, `ControlType`, `AutomationId`, `Name`, `RefKey`, `Properties` dict, and for PropertyChange: `ChangedProperty`, `OldValue`, `NewValue`. For Keypress: `KeyName`, `KeyCombo`.

### MCP Tool Output Format
```
Session: a1b2c3d4 | Started: 14:23:05 | Stopped: 14:25:12 | Entries: 47

14:23:05.123 [Focus]  [TextBox] #NameField  (Value="hello")
14:23:06.456 [Hover]  [Button] #SaveButton
14:23:07.789 [PropChange] [TextBox] #NameField  Value: "hello" → "hello world"
14:23:08.012 [Keypress]  Ctrl+S  (on [TextBox] #NameField)
```

### AI Agent Workflow
1. Agent calls `wpf_watch_start` — session begins recording
2. User interacts with the WPF application
3. Agent calls `wpf_watch_stop` — receives full structured session log
4. Agent analyzes entries to understand what the user did
5. Agent can convert the session into a reusable macro via `wpf_save_macro`

### Hover Watcher
Uses `GetCursorPos` P/Invoke + `AutomationElement.FromPoint()` in `UiaEngine.GetElementAtCursor()`. Filters to attached process by PID. Focus changes take priority over hover for auto-selection when both change in the same tick.

### Keyboard Hook (Keypress Capture)
Uses `SetWindowsHookEx(WH_KEYBOARD_LL)` with a dedicated STA thread running a `GetMessage` message pump. The hook is system-wide but filters to the attached process by checking `GetForegroundWindow()` PID. Modifier keys (Ctrl, Alt, Shift, Win) are tracked for combo detection (e.g., `Ctrl+S`). Standalone modifier presses are not logged. The `_hookProc` delegate is stored in a field to prevent GC collection. `VkToKeyName()` uses reverse lookup from `System.Windows.Input.Key` enum via `KeyInterop.KeyFromVirtualKey()`.

### Why Polling, Not UIA Events
The STA thread uses a custom `BlockingQueue`, not a Windows message pump. `Automation.AddAutomationFocusChangedEventHandler` requires a COM message pump to fire reliably. Polling every 500ms is the pragmatic approach. Same reasoning for hover — no UIA hover event exists.

### BoundingRectangle Filter
This property changes constantly as elements scroll/resize — filtered out from property change diff logging to prevent log spam.

### LogPanel Auto-Scroll
- JS interop: `window.scrollToBottom(id)` function in `App.razor` sets `el.scrollTop = el.scrollHeight`
- `LogPanel.razor` injects `IJSRuntime`, sets `_shouldScroll = true` on new log entries
- `OnAfterRenderAsync` calls `scrollToBottom("log-scroll")` when `_shouldScroll` is set, then resets the flag
- Catches `ObjectDisposedException` for circuit disconnect safety

## Web Dashboard Theming

### Dual Light/Dark Theme
- **Light theme**: Deltek-inspired — blue header (`#0066FF`), Inter font, warm gray (`#E8EBF0`) content backgrounds, blue accents
- **Dark theme**: Original purple accents (`#7c3aed` / `#a78bfa`), dark surface colors
- **Strategy**: Tailwind `darkMode: 'class'` — toggling `class="dark"` on `<html>` element
- **OS detection**: Reads `prefers-color-scheme: dark` on first visit
- **Persistence**: Theme choice saved to `localStorage`, restored before Tailwind CDN loads (prevents flash-of-wrong-theme)
- **Toggle**: Sun/moon button in header bar, calls `window.toggleTheme()` JS function

### Tailwind Color Tokens (App.razor)
```javascript
tailwind.config = {
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        dm: { bg: '#1e1e2e', surface: '#2a2a3c', ... },  // dark mode surfaces
        accent: { DEFAULT: '#7c3aed', light: '#a78bfa' }  // purple accents for dark mode
      }
    }
  }
}
```

### Custom CSS Classes (App.razor `<style>` block)
| Class | Light | Dark |
|-------|-------|------|
| `.panel-header` | Deltek blue bg, white text | Dark surface bg, purple text |
| `.panel-card` | White bg, gray border | Dark bg, dark border |
| `.input-field` | Standard light input | Dark input with purple focus ring |
| `.btn-primary` | Deltek blue | Purple (`accent`) |
| `.btn-secondary` | Gray outline | Dark outline |

### JS Functions (App.razor `<script>` block)
- `window.getTheme()` — returns current theme from `localStorage` or OS preference
- `window.setTheme(theme)` — applies theme class + saves to `localStorage`
- `window.toggleTheme()` — toggles between light/dark
- `window.syncThemeIcon()` — updates sun/moon icon visibility
- `window.scrollToBottom(id)` — auto-scroll helper for LogPanel

### Key Design Decisions
- Tailwind CSS loaded via CDN (`cdn.tailwindcss.com`) with inline config — no build step
- All 9 Razor components have `dark:` variant classes for every themed element
- Header text: white process name + white/70% PID on blue header (no green text on blue)
- Content areas use `#E8EBF0` (warm gray) not pure white — reduces brightness
- Macro backgrounds consistent across all panels (same `#E8EBF0`)

## Macro Execution Logging

Per-step logging for macro execution, visible in both terminal (stderr) and web dashboard log panel.

### Architecture
1. `MacroEngine.ExecuteAsync()` / `ExecuteDefinitionAsync()` / `ExecuteInternalAsync()` accept an optional `Action<string>? onLog` callback (default `null`)
2. `FormatStepSummary()` static helper formats a human-readable summary for each step, covering all 21 action types with parameter values
3. Before each step: logs `[Macro] Step {n}/{total}: {action} ({params})`
4. After each step: logs `[Macro] Step {n}/{total}: OK — {result}` or `FAILED — {error}`

### Caller Wiring
| Caller | onLog implementation |
|--------|---------------------|
| `AppState` (web dashboard) | `msg => Log(LogLevel.Info, msg)` — appears in LogPanel |
| `UiaProxy` (pipe server) | `msg => Console.Error.WriteLine(msg)` — stderr for MCP client visibility |
| `Tools.cs` (direct MCP) | `msg => Console.Error.WriteLine(msg)` — stderr fallback |

### Log Format Examples
```
[Macro] Step 1/5: find (automation_id=uxProjectsView)
[Macro] Step 1/5: OK — Found [e3]
[Macro] Step 2/5: click (ref=e3)
[Macro] Step 2/5: OK — Clicked
[Macro] Step 3/5: send_keys (keys=Alt,F)
[Macro] Step 3/5: OK — Keys sent
[Macro] Step 4/5: file_dialog (path=C:\data\test.xer)
[Macro] Step 4/5: OK — File selected
[Macro] Step 5/5: verify (ref=e3, property=value, expected=Done, match_mode=not_equals)
[Macro] Step 5/5: FAILED (not_equals) — Expected "Done" but got "Processing"
```

### FormatStepSummary Coverage
Covers all 22 action types: `launch`, `wait_for_window`, `wait_for_enabled`, `attach`, `focus`, `find`, `find_by_path`, `click`, `right_click`, `type`, `set_value`, `get_value`, `send_keys`, `keys`, `wait`, `snapshot`, `screenshot`, `properties`, `children`, `file_dialog`, `verify`, `run_script`. Each type extracts relevant fields (e.g., `automation_id` for `find`, `keys` for `send_keys`, `property`+`expected`+`match_mode` for `verify`, `command`+`args`+`save_output_as` for `run_script`).

### Files Modified
- `MacroEngine.cs` — `onLog` parameter on execute methods, `FormatStepSummary()` static helper, step loop pre/post logging
- `Web/AppState.cs` — passes log callback to `ExecuteAsync`
- `UiaProxy.cs` — passes stderr callback for `runMacro` and `executeMacroYaml` commands
- `Tools.cs` — passes stderr callback for direct-mode `wpf_macro` fallback

## Macro Cancellation

User-initiated cancellation of running macros from the web dashboard and CLI.

### Architecture
1. `MacroEngine` already accepts `CancellationToken cancellation` on all execute methods (`ExecuteAsync`, `ExecuteDefinitionAsync`, `ExecuteInternalAsync`)
2. Cancellation is checked before each step and propagates through linked `CancellationTokenSource` chains (caller → macro timeout → step timeout)
3. For `run_script` steps, cancellation kills the child process tree via `proc.Kill(entireProcessTree: true)`
4. Log messages distinguish "CANCELLED" (user-initiated) from "TIMEOUT" (macro/step timeout) by checking `cancellation.IsCancellationRequested`

### Web Dashboard
- `AppState` owns a `CancellationTokenSource? _macroCts` field, created at the start of `RunMacroAsync()`, disposed in `finally`
- `CancelMacro()` calls `_macroCts?.Cancel()` — thread-safe (CTS.Cancel is thread-safe)
- `IsMacroRunning` property returns `_macroCts != null`
- `MacroRunner.razor` shows a red **Cancel** button while a macro is running (replaces the "Run Macro" button)

### CLI Mode
- Static `CancellationTokenSource? _macroCts` field in `CliMode`
- `Console.CancelKeyPress` handler: if a macro is running (`_macroCts != null`), cancels the CTS and sets `e.Cancel = true` to prevent process termination; otherwise lets Ctrl+C terminate normally
- Token is passed to `ExecuteAsync` / `ExecuteDefinitionAsync` for `macro`, `run`, and bare YAML path execution

### MCP / Proxy — NOT SUPPORTED
Cancellation is not available through MCP tools or the proxy pipe. The proxy server handles commands synchronously (`.GetAwaiter().GetResult()`) which blocks the pipe reader thread — a `cancelMacro` command cannot be received while a macro is running. This is the same root cause as the documented pipe deadlock bug.

### Files Modified
- `IAppState.cs` — added `CancelMacro()`, `IsMacroRunning` to interface
- `AppState.cs` — `_macroCts` field, `CancelMacro()`, `IsMacroRunning`, token passed in `RunMacroAsync`
- `MacroRunner.razor` — conditional Cancel/Run button, `CancelMacro()` method
- `CliMode.cs` — `_macroCts` field, `Console.CancelKeyPress` handler, token passed in `macro`/`run`/bare-YAML paths
- `MacroEngine.cs` — `ExecuteInternalAsync` pre-step check and `OperationCanceledException` catch now distinguish user cancel vs timeout; `run_script` rethrows if parent token cancelled (so step loop reports correct reason)
- `MacroEngineTests.cs` — 4 cancellation tests (already-cancelled token, cancel during wait step, cancel during run_script, cancel log message)

## Discoveries & Gotchas

- **MCP Tool Timeout (~15-20s)**: The MCP client (OpenCode) has a hard ~15-20s timeout on tool call responses. This cannot be configured. Keep macros fast. Reduce `wait` steps to 2-3s max.
- **Do NOT use sub-macros (`action: macro`)**: Nested macro calls via the `macro` step type will always exceed the MCP client timeout because the parent macro's execution time includes the full sub-macro duration. Always **inline** the steps from sub-macros directly into the parent macro YAML instead of using `action: macro`. The `macro` step type exists in the engine but is not usable in practice due to this timeout constraint.
- **File dialogs**: Two types — standard Win32 (`AutomationId="1148"`, `wpf_file_dialog` works) and DirectUI Save (`AutomationId="FileNameControlHost"`, must use `wpf_find` + `wpf_type` + `Enter`).
- **`wpf_screenshot` only captures main app window** — modal OS dialogs are NOT visible.
- **Sample file gotcha**: `Initial  Plan.xer` has a double space in the filename.
- **Blazor Server in WPF host — "Assembly already defined"**: When hosting Blazor from a `UseWPF` project, `WebApplicationOptions.ApplicationName` must be set to the RCL assembly name (e.g., `typeof(App).Assembly.GetName().Name`) and `AddAdditionalAssemblies` must NOT re-add the same assembly used in `MapRazorComponents<App>()`.
- **WSL2 cannot reach Windows localhost ports**: Kestrel running on Windows binds to `0.0.0.0` but WSL2 (VM-based) can't connect to `localhost:5112`. Windows browsers can. This is a WSL2 networking limitation, not a code bug.
- **Pipe deadlock on slow commands (KNOWN BUG)**: `UiaProxyClient.CallAsync()` holds a `SemaphoreSlim(1,1)` lock during the entire request/response cycle. All `Tools.cs` calls pass **no CancellationToken**. When a slow server command (e.g., macro with file dialog + import exceeding ~15-20s) blocks on `ReadLineAsync`, the lock is held indefinitely and all subsequent MCP tool calls deadlock on `_lock.WaitAsync()`. This requires restarting the MCP server to recover. Two tests in `UiaProxyProtocolTests.cs` reproduce this: `CallAsync_NoCancellationToken_SlowServer_BlocksSubsequentCalls` (deadlock) and `CallAsync_SlowServer_LateResponse_PipeStaysInSync` (pipe stays in sync when server eventually responds).
