# WPF MCP Server

Generic MCP (Model Context Protocol) server that automates any WPF application via UI Automation. Primary target is **Deltek Acumen Fuse** (`Fuse.exe`), which uses Infragistics controls.

## Project Structure

```
WpfMcp.slnx              # Solution (3 projects)
WpfMcp/                   # Main project (net9.0-windows, UseWPF)
WpfMcp.Web/               # Razor Class Library — Blazor Server dashboard components
WpfMcp.Tests/             # xUnit tests
publish/macros/           # Version-controlled macro YAML files (product subfolders)
publish/Shortcuts/        # Exported .lnk shortcuts (gitignored, generated by --export-all)
publish/setup.cmd         # Post-extraction script to generate shortcuts
.github/workflows/        # CI/CD: build, test, release zip
```

Flat layout — NO `src/` or `tests/` subdirectories.

## Architecture: Two-Process Proxy

```
OpenCode (WSL)
  → cmd.exe /c WpfMcp.exe --mcp-connect  (non-elevated, MCP stdio server)
    → auto-launches WpfMcp.exe --server   (elevated via BeyondTrust/UAC)
    → UiaProxyClient connects to WpfMcp_UIA named pipe
    → MCP tool calls proxy through pipe → UiaProxyServer executes UIA commands
```

**Why elevation?** Fuse's UIA providers only respond to elevated processes. Non-elevated processes see only `FrameworkId="Win32"` with a single TitleBar child.

### Web Dashboard

The elevated `--server` process also hosts a **Blazor Server dashboard** on `http://localhost:5112` for interactive WPF element inspection, actions, and macro running.

```
WpfMcp.Web (RCL)           → IAppState interface + DTOs + Razor components
WpfMcp (main project)      → AppState implementation + WebServer.cs Kestrel host
```

- **Styling**: Tailwind CSS via CDN, dark theme
- **Communication**: Blazor Server's built-in SignalR (real-time, no polling)
- **Binding**: `http://*:5112` (all interfaces, accessible from WSL and LAN)
- **One-way dependency**: `WpfMcp` references `WpfMcp.Web`; the RCL has no reference back
- **Shared singletons**: `UiaEngine.Instance`, `ElementCache`, `MacroEngine`, and `_commandLock` are shared between pipe server and web dashboard via `AppState`

## Build & Test

```bash
# MUST kill running instances first or build fails with file lock errors
cmd.exe /c "taskkill /IM WpfMcp.exe /F 2>nul"

# Build
cmd.exe /c "cd /d C:\WpfMcp && dotnet build WpfMcp.slnx"

# Test (132 tests)
cmd.exe /c "cd /d C:\WpfMcp && dotnet test WpfMcp.Tests"

# Release build + local publish
cmd.exe /c "cd /d C:\WpfMcp && dotnet build WpfMcp\WpfMcp.csproj -c Release"
```

The machine has .NET 10 preview SDK installed; we target `net9.0-windows`.

## Critical Technical Constraints

### WSL ↔ Windows
- OpenCode runs on WSL, launches Windows exe via `cmd.exe /c`
- WSL `/mnt/c/` writes can silently fail — use `cmd.exe` or `powershell.exe` for writing Windows files when reliability matters
- Use the `Write` tool for simple file writes; it works for most cases

### Named Pipe ACL
- Elevated server pipe needs `PipeSecurity` with `AuthenticatedUserSid` or non-elevated clients can't connect

### MCP Logging
- Must use `builder.Logging.ClearProviders()` then add console with `LogToStandardErrorThreshold = LogLevel.Trace` to prevent stdout corruption (MCP uses stdout for JSON-RPC)

### NuGet
- Local `nuget.config` with `<clear />` needed to avoid Infragistics NuGet source errors
- `ModelContextProtocol` NuGet version: `0.9.0-preview.2`
- Server instructions (`options.ServerInstructions`) inject macro list + full knowledge base YAML at MCP handshake

### Publish / Runtime
- `publish/` folder must include `runtimes/` subdirectory — `System.Text.Encodings.Web` v10.0.0.0 assembly is needed at runtime
- `Environment.ProcessPath` for exe location (NOT `AppContext.BaseDirectory` which points to temp extraction dir for single-file publish)

### Process Launch Relay
- Some apps (Windows 11 Notepad, store apps) exit immediately on `Process.Start` and relaunch under a different PID
- `WaitForProcessByNameAsync` handles this by falling back to process-name search when the tracked PID exits

## Key Code Patterns

### JsonElement Null Safety
When MCP passes `null` for optional params, always check `ValueKind` before calling `GetString()`/`GetInt32()`:
```csharp
private static string? GetStringArg(JsonElement args, string name) =>
    args.TryGetProperty(name, out var v) && v.ValueKind == JsonValueKind.String ? v.GetString() : null;
```

### YamlDotNet Configuration
Always use `UnderscoredNamingConvention` and `IgnoreUnmatchedProperties`. Use `[YamlMember(Alias = "...")]` attributes on POCOs. Shared deserializer/serializer instances live in `YamlHelpers.cs` — never create inline instances.

### ControlType Lookup
Uses reflection-based static dictionary on `ControlType`'s public fields.

### Key Parsing
`ParseVirtualKey` uses `System.Windows.Input.Key` enum + `KeyInterop.VirtualKeyFromKey()`. Bare digits "0"-"9" must be aliased to "D0"-"D9".

### xUnit Test Isolation
- Pipe tests must use unique pipe names per test (GUID suffix) since xUnit runs in parallel
- `WpfToolsTests` and `ProxyResponseFormattingTests` share the static `WpfTools.Proxy` — both use `[Collection("WpfTools")]` to prevent parallel execution
- MacroEngine tests use `enableWatcher: false` constructor param to avoid filesystem race conditions
- FileSystemWatcher tests need ~1500ms delay for debounce (500ms) + processing

## Macro System

### YAML Format
```yaml
name: My Macro
description: What it does
timeout: 60
parameters:
  - name: paramName
    description: What this param is
    required: true
    default: "optional default"
steps:
  - action: launch
    exe_path: "{{paramName}}"
    if_not_running: true
    timeout: 45
  - action: wait_for_window
    title_contains: "My App"
    timeout: 30
  - action: focus
  - action: find
    automation_id: myElement
    save_as: el
  - action: click
    ref: el
  - action: type
    text: "{{paramName}}"
  - action: send_keys
    keys: "Ctrl+S"
  - action: wait
    seconds: 2
  - action: verify
    ref: el
    property: value          # value, name, toggle_state, is_enabled, expand_state, is_selected, control_type, automation_id
    expected: "Done"
    message: "Optional custom failure message"
```

### Step Types
`launch`, `wait_for_window`, `wait_for_enabled`, `attach`, `focus`, `find`, `find_by_path`, `click`, `right_click`, `type`, `set_value`, `get_value`, `send_keys`, `keys` (alias), `wait`, `snapshot`, `screenshot`, `properties`, `children`, `file_dialog`, `verify`

> **Note:** `macro` (sub-macro) step type exists in the engine but should NOT be used — it will always exceed the MCP client timeout. Inline the sub-macro steps instead.

### Macros Path Resolution
`Constants.ResolveMacrosPath()`: explicit `--macros-path` arg > `WPFMCP_MACROS_PATH` env var > `macros/` next to exe

### File Watcher
`MacroEngine` watches the macros folder with FileSystemWatcher (500ms debounce). Auto-reloads on create/modify/delete/rename. `LoadErrors` property tracks YAML parse failures.

## Conventions (DLTKEngineering)

- Repo naming: `[team]-[repo]`, lowercase+hyphens
- Branch prefixes: `feature/`, `bugfix/`, `release/`
- xUnit for tests
- File-scoped namespaces (`namespace WpfMcp;`)
- Private fields: `_camelCase`
- Constants: `PascalCase`

## Git

- Remote: `https://github.com/danielenerrodriguez/acumen-wpf-mcp`
- Branch: `master`
- Do NOT push — let the user push manually
- Do NOT create ZenDesk tickets

## Knowledge Base System

Product-specific knowledge bases provide AI agents with the context they need to navigate WPF applications — automation IDs, keytips, keyboard shortcuts, ribbon structure, workflows, and more.

### File Convention
- Knowledge bases are YAML files named `_knowledge.yaml` (underscore prefix)
- Located in product subfolders: `publish/macros/{product}/_knowledge.yaml`
- Skipped by the macro loader (underscore prefix exclusion)
- Must have `kind: knowledge-base` as a top-level field

### How It Works
1. **`MacroEngine.Reload()`** loads `_knowledge.yaml` files into `_knowledgeBases` dictionary (keyed by product folder name)
2. **`wpf_macro_list`** includes a condensed summary for each knowledge base (verified keytips, key automation IDs, workflow/tip counts)
3. **MCP Resource** `knowledge://{productName}` serves the full YAML content via `Resources.cs`
4. Parsed as `Dictionary<string, object>` (not POCOs) — flexible, no C# changes needed when YAML schema changes

### Knowledge Base YAML Structure
```yaml
kind: knowledge-base
update_instructions: { ... }    # When/how AI agents should update this file
installation: { ... }           # Exe path, samples, templates, skills directories
application: { ... }            # Name, version, startup phases
keyboard_shortcuts: [ ... ]     # InputBinding shortcuts (Ctrl+N, Ctrl+O, etc.)
keytips: { ... }                # Application menu + ribbon tab keytip sequences
ribbon: { ... }                 # Complete ribbon structure (tabs, groups, tools, commands)
automation_ids: { ... }         # 80+ IDs by category (panels, grids, trees, etc.)
workflows: [ ... ]              # Step-by-step recipes for common tasks
navigation_tips: [ ... ]        # Practical tips for driving the application
data_formats: { ... }           # Supported import/export formats
```

### Current Knowledge Bases
- `acumen-fuse` — Deltek Acumen Fuse (1800+ lines, 100+ automation IDs, 15 workflows, 19 navigation tips)

## File Reference

| File | Purpose |
|------|---------|
| `WpfMcp/Program.cs` | Entry point: mode routing (`--server`, `--mcp-connect`, `--mcp`, `--export-all`, drag-drop, CLI) |
| `WpfMcp/Constants.cs` | Shared constants, `ResolveMacrosPath()`, `ResolveShortcutsPath()`, `WebPort`, `Commands` nested class |
| `WpfMcp/Tools.cs` | 20 MCP tool definitions (including watch mode) |
| `WpfMcp/UiaEngine.cs` | Core UI Automation engine (STA thread, SendInput, launch, wait, `ReadElementProperty()`) |
| `WpfMcp/UiaProxy.cs` | Proxy client/server over named pipe + web dashboard startup |
| `WpfMcp/MacroDefinition.cs` | YAML POCOs for macros + `KnowledgeBase` + `SaveMacroResult` + `ExportMacroResult` records |
| `WpfMcp/MacroEngine.cs` | Load/validate/execute/save/export macros, FileSystemWatcher, knowledge base loading |
| `WpfMcp/MacroSerializer.cs` | YAML serialization (`ToYaml`, `SaveToFile`) |
| `WpfMcp/CliMode.cs` | Interactive CLI for manual testing (`read-prop`, `verify` commands) |
| `WpfMcp/ElementCache.cs` | Thread-safe LRU element reference cache (e1, e2, ..., max 500) |
| `WpfMcp/JsonHelpers.cs` | Shared JSON array parsing utilities (`ParseJsonArray`, `ConvertJsonElement`) |
| `WpfMcp/YamlHelpers.cs` | Shared YAML deserializer/serializer singleton instances |
| `WpfMcp/ShortcutCreator.cs` | COM-based `.lnk` shortcut creation via `WScript.Shell` |
| `WpfMcp/Resources.cs` | MCP resources — `knowledge://{productName}` endpoint |
| `WpfMcp/Web/WebServer.cs` | Kestrel startup for Blazor Server dashboard |
| `WpfMcp/Web/AppState.cs` | `IAppState` implementation wrapping UiaEngine + ElementCache + MacroEngine |
| `WpfMcp.Web/IAppState.cs` | Interface + DTOs for web dashboard (ElementInfo, ActionResult, etc.) |
| `WpfMcp.Web/Components/` | Razor components: App, Routes, Layout, Dashboard, ElementTree, TreeNode, PropertiesPanel, ActionsPanel, MacroRunner, LogPanel |

## Macro Saving (`wpf_save_macro`)

AI agents can save workflows they've performed as reusable macro YAML files using the `wpf_save_macro` MCP tool.

### How It Works
1. Agent passes steps as a JSON array, plus name/description/parameters
2. `MacroEngine.ValidateSteps()` checks all action types and required fields
3. `MacroEngine.GetProductFolder()` scans knowledge bases for a matching `process_name` field to auto-derive the product folder (e.g., `Fuse` → `acumen-fuse`)
4. Steps are serialized to clean YAML (no JSON-in-YAML) via YamlDotNet
5. File is written to `{macrosPath}/{productFolder}/{name}.yaml`
6. FileSystemWatcher auto-reloads the new macro immediately

### Key Design Decisions
- Steps passed as JSON string in, written as clean YAML out
- Product folder auto-derived from attached process matching knowledge base `application.process_name`
- Validation against 21 known action types with per-action required field checks
- `force` parameter (bool, default false) for overwrite protection
- `SaveMacroResult` record returns `(Ok, FilePath, MacroName, Message)`

### Error Cases
1. No process attached → error
2. Can't derive product folder → error with suggestion to include folder in name
3. Macro already exists and `force` is false → error with overwrite hint
4. Invalid step action → error listing all valid actions
5. Missing required step fields → error naming the missing field and step number

### Files Modified
- `MacroDefinition.cs` — `SaveMacroResult` record
- `MacroEngine.cs` — `SaveMacro()`, `GetProductFolder()`, `ValidateSteps()`, `MacrosPath` property
- `Tools.cs` — `wpf_save_macro` MCP tool (uses `JsonHelpers.ParseJsonArray`)
- `UiaProxy.cs` — `saveMacro` case in `ExecuteCommand()` (uses `JsonHelpers.ParseJsonArray`)
- `JsonHelpers.cs` — shared `ParseJsonArray()` / `ConvertJsonElement()` utilities
- `UiaEngine.cs` — `ProcessName` property
- `_knowledge.yaml` — `saving_workflows` section under `update_instructions`

## Macro Export (`wpf_export_macro`)

Macros can be exported as Windows shortcut (.lnk) files that users can double-click to run without needing OpenCode/MCP.

### How It Works
1. The shortcut targets `WpfMcp.exe "path\to\macro.yaml"`, reusing the existing drag-and-drop execution mode
2. The drag-and-drop mode handles everything: YAML parsing, parameter prompting, elevated server connection, execution
3. The client process runs **non-elevated** — `EnsureServerAndConnectAsync` only triggers UAC if the elevated server isn't already running (first run only)
4. Shortcuts are placed in `Shortcuts/` as a sibling of the `macros/` folder, mirroring the macro directory structure

### Access Points
- **MCP tool**: `wpf_export_macro` — pass a macro name or `"all"` to export all macros
- **CLI mode**: `export <name>` or `export-all`
- **Command line**: `WpfMcp.exe --export-all [--shortcuts-path C:\path] [--force]`
- **Post-install**: `setup.cmd` runs `--export-all` for users who extract the release zip

### Shortcuts Path Resolution
`Constants.ResolveShortcutsPath()`: explicit `--shortcuts-path` arg > `WPFMCP_SHORTCUTS_PATH` env var > `Shortcuts/` as sibling of macros folder

### Key Design Decisions
- Shortcuts do NOT have the "Run as administrator" flag — elevation is handled internally by the drag-and-drop mode
- `.lnk` files are created via COM interop (`WScript.Shell`) with run-as-admin support via binary patch at byte 0x15
- Shortcut names match macro names (e.g., `import-xer.lnk`)
- `ExportMacroResult` record returns `(Ok, ShortcutPath, MacroName, Message)`
- Overwrite protection via `force` parameter (default false)
- Generated `.lnk` files are gitignored (machine-specific absolute paths)

### Files
- `ShortcutCreator.cs` — COM-based `.lnk` creation utility
- `MacroEngine.cs` — `ExportMacro()`, `ExportAllMacros()`
- `Tools.cs` — `wpf_export_macro` MCP tool
- `UiaProxy.cs` — `exportMacro`, `exportAllMacros` proxy commands
- `CliMode.cs` — `export`, `export-all` CLI commands
- `Program.cs` — `--export-all`, `--shortcuts-path` CLI flags
- `publish/setup.cmd` — Post-extraction script included in release zip

## Live Updates & Focus Watcher

### Event-Driven Updates
The web dashboard receives live updates via in-process C# events (not pipe push — the named pipe is request/response only):
- **`OnLog` event**: New log entries trigger `StateHasChanged()` in `LogPanel`, with auto-scroll via JS interop (`scrollToBottom`)
- **`OnAttachChanged` event**: Fires when a process is attached/detached — `MainLayout` refreshes status bar, `Dashboard` refreshes element tree
- **`OnWatchEntry` event**: New watch entries trigger element auto-selection and property highlighting in Dashboard
- **`OnWatchStateChanged` event**: Fires when watch is started/stopped from any source — Dashboard updates the Watch toggle button
- **`OnMacrosChanged` event**: Fires when FileSystemWatcher reloads macros — MacroRunner auto-refreshes the macro list
- **Status bar polling**: `MainLayout` polls `GetStatus()` every 3 seconds for process name + PID display

### Watch Mode (Server-Side Sessions)

Watch mode records focus changes, hover changes, keypresses, and property diffs in the attached WPF application. The watch timer runs **server-side in AppState** (not in the Dashboard), so it works from MCP tools, CLI, and web dashboard simultaneously.

**Architecture:**
1. `AppState` owns a 500ms `System.Threading.Timer` that polls `AutomationElement.FocusedElement` and `AutomationElement.FromPoint()` (via `GetCursorPos`)
2. Each detected change creates a structured `WatchEntry` record, appended to the active `WatchSession`
3. Entries also flow into the main log (for dashboard visibility) and fire `OnWatchEntry` event
4. Dashboard subscribes to `OnWatchEntry` for live element selection and property highlighting
5. Only the **last completed session** is retained in memory (no disk persistence)

**Watch session lifecycle:**
- `StartWatch()` → creates new `WatchSession`, starts timer, starts keyboard hook, resets runtime IDs, fires `OnWatchStateChanged`
- `StopWatch()` → stops timer, stops keyboard hook, timestamps session, moves to `_lastSession`, fires `OnWatchStateChanged`
- `GetWatchSession()` → returns current (active) or last (completed) session

**Access points:**
- **MCP tools**: `wpf_watch_start`, `wpf_watch_stop`, `wpf_watch_status`
- **CLI commands**: `watch`, `watch stop`, `watch status`
- **Web dashboard**: Watch toggle button in ActionsPanel (uses same server-side session)

### WatchEntry Types
- **`Focus`** — keyboard focus changed to a new element
- **`Hover`** — mouse cursor moved over a new element
- **`Keypress`** — a key was pressed while the attached application had foreground focus
- **`PropertyChange`** — a property value changed on the currently tracked element

Each entry includes: `Time`, `Kind`, `ControlType`, `AutomationId`, `Name`, `RefKey`, `Properties` dict, and for PropertyChange: `ChangedProperty`, `OldValue`, `NewValue`. For Keypress: `KeyName`, `KeyCombo`.

### MCP Tool Output Format
```
Session: a1b2c3d4 | Started: 14:23:05 | Stopped: 14:25:12 | Entries: 47

14:23:05.123 [Focus]  [TextBox] #NameField  (Value="hello")
14:23:06.456 [Hover]  [Button] #SaveButton
14:23:07.789 [PropChange] [TextBox] #NameField  Value: "hello" → "hello world"
14:23:08.012 [Keypress]  Ctrl+S  (on [TextBox] #NameField)
```

### AI Agent Workflow
1. Agent calls `wpf_watch_start` — session begins recording
2. User interacts with the WPF application
3. Agent calls `wpf_watch_stop` — receives full structured session log
4. Agent analyzes entries to understand what the user did
5. Agent can convert the session into a reusable macro via `wpf_save_macro`

### Hover Watcher
Uses `GetCursorPos` P/Invoke + `AutomationElement.FromPoint()` in `UiaEngine.GetElementAtCursor()`. Filters to attached process by PID. Focus changes take priority over hover for auto-selection when both change in the same tick.

### Keyboard Hook (Keypress Capture)
Uses `SetWindowsHookEx(WH_KEYBOARD_LL)` with a dedicated STA thread running a `GetMessage` message pump. The hook is system-wide but filters to the attached process by checking `GetForegroundWindow()` PID. Modifier keys (Ctrl, Alt, Shift, Win) are tracked for combo detection (e.g., `Ctrl+S`). Standalone modifier presses are not logged. The `_hookProc` delegate is stored in a field to prevent GC collection. `VkToKeyName()` uses reverse lookup from `System.Windows.Input.Key` enum via `KeyInterop.KeyFromVirtualKey()`.

### Why Polling, Not UIA Events
The STA thread uses a custom `BlockingQueue`, not a Windows message pump. `Automation.AddAutomationFocusChangedEventHandler` requires a COM message pump to fire reliably. Polling every 500ms is the pragmatic approach. Same reasoning for hover — no UIA hover event exists.

### BoundingRectangle Filter
This property changes constantly as elements scroll/resize — filtered out from property change diff logging to prevent log spam.

### LogPanel Auto-Scroll
- JS interop: `window.scrollToBottom(id)` function in `App.razor` sets `el.scrollTop = el.scrollHeight`
- `LogPanel.razor` injects `IJSRuntime`, sets `_shouldScroll = true` on new log entries
- `OnAfterRenderAsync` calls `scrollToBottom("log-scroll")` when `_shouldScroll` is set, then resets the flag
- Catches `ObjectDisposedException` for circuit disconnect safety

## Discoveries & Gotchas

- **MCP Tool Timeout (~15-20s)**: The MCP client (OpenCode) has a hard ~15-20s timeout on tool call responses. This cannot be configured. Keep macros fast. Reduce `wait` steps to 2-3s max.
- **Do NOT use sub-macros (`action: macro`)**: Nested macro calls via the `macro` step type will always exceed the MCP client timeout because the parent macro's execution time includes the full sub-macro duration. Always **inline** the steps from sub-macros directly into the parent macro YAML instead of using `action: macro`. The `macro` step type exists in the engine but is not usable in practice due to this timeout constraint.
- **File dialogs**: Two types — standard Win32 (`AutomationId="1148"`, `wpf_file_dialog` works) and DirectUI Save (`AutomationId="FileNameControlHost"`, must use `wpf_find` + `wpf_type` + `Enter`).
- **`wpf_screenshot` only captures main app window** — modal OS dialogs are NOT visible.
- **Sample file gotcha**: `Initial  Plan.xer` has a double space in the filename.
- **Blazor Server in WPF host — "Assembly already defined"**: When hosting Blazor from a `UseWPF` project, `WebApplicationOptions.ApplicationName` must be set to the RCL assembly name (e.g., `typeof(App).Assembly.GetName().Name`) and `AddAdditionalAssemblies` must NOT re-add the same assembly used in `MapRazorComponents<App>()`.
- **WSL2 cannot reach Windows localhost ports**: Kestrel running on Windows binds to `0.0.0.0` but WSL2 (VM-based) can't connect to `localhost:5112`. Windows browsers can. This is a WSL2 networking limitation, not a code bug.
